<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>WebGL2 - Skinning</title>
<link type="text/css" href="resources/webgl-tutorials.css" rel="stylesheet" />
</head>
<body>
<canvas id="canvas"></canvas>
</body>
<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See http://webgl2fundamentals.org/webgl/lessons/webgl-boilerplate.html
and http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
-->
<script src="resources/webgl-utils.js"></script>
<script src="resources/webgl-lessons-helper.js"></script> <!-- you can delete this script. it is only used on the site to help with errors -->
<script src="resources/3d-math.js"></script>
<script>
"use strict";

const simpleVertexShaderSource = `#version 300 es
in vec4 position;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

void main() {
  gl_Position = projection * view * model * position;
}
`;

const skinningVertexShaderSource = `#version 300 es

in vec4 position;
in vec4 weight;
in vec4 boneNdx;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 bones[4];

void main() {

  gl_Position = projection * view *
                (bones[int(boneNdx[0])] * position * weight[0] +
                 bones[int(boneNdx[1])] * position * weight[1] +
                 bones[int(boneNdx[2])] * position * weight[2] +
                 bones[int(boneNdx[3])] * position * weight[3]);

}
`;

const fragmentShaderSource = `#version 300 es
precision mediump float;

uniform vec4 color;

out vec4 outColor;

void main () {
  outColor = color;
}
`;

function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  var canvas = document.getElementById("canvas");
  var gl = canvas.getContext("webgl2");
  if (!gl) {
    return;
  }

  // Use our boilerplate utils to compile the shaders and link into a program
  const skinningProgramInfo = webglUtils.createProgramInfo(
      gl, [skinningVertexShaderSource, fragmentShaderSource]);

  var arrays = {
    position: {
      numComponents: 2,
      data: [
       0,  1,  // 0
       0, -1,  // 1
       2,  1,  // 2
       2, -1,  // 3
       4,  1,  // 4
       4, -1,  // 5
       6,  1,  // 6
       6, -1,  // 7
       8,  1,  // 8
       8, -1,  // 9
      ],
    },
    boneNdx: {
      numComponents: 4,
      data: [
        0, 0, 0, 0,  // 0
        0, 0, 0, 0,  // 1
        0, 1, 0, 0,  // 2
        0, 1, 0, 0,  // 3
        1, 0, 0, 0,  // 4
        1, 0, 0, 0,  // 5
        1, 2, 0, 0,  // 6
        1, 2, 0, 0,  // 7
        2, 0, 0, 0,  // 8
        2, 0, 0, 0,  // 9
      ],
    },
    weight: {
      numComponents: 4,
      data: [
       1,  0, 0, 0,  // 0
       1,  0, 0, 0,  // 1
      .5, .5, 0, 0,  // 2
      .5, .5, 0, 0,  // 3
       1,  0, 0, 0,  // 4
       1,  0, 0, 0,  // 5
      .5, .5, 0, 0,  // 6
      .5, .5, 0, 0,  // 7
       1,  0, 0, 0,  // 8
       1,  0, 0, 0,  // 9
      ],
    },

    indices: [
      0, 1,
      0, 2,
      1, 3, //
      2, 3,
      2, 4,
      3, 5, //
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  };

  var skinningBufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);

  // Create a vertex array object (attribute state)
  var skinningVao = gl.createVertexArray();
  // and make it the one we're currently working with
  gl.bindVertexArray(skinningVao);
  // set all the attributes
  webglUtils.setBuffersAndAttributes(gl, skinningProgramInfo, skinningBufferInfo);

  var boneArray = new Float32Array(4 * 16);

  var uniforms = {
    projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
    view: m4.translation(-6, 0, 0),
    bones: boneArray,
    color: [1, 0, 0, 1],
  };

  // make views for each bone. This lets all the bones
  // exist in 1 array for uploading but as separate
  // arrays for using with the math functions
  var boneUniforms = [];  // the uniform data
  var bones = [];         // the value before multiplying by inverse bind matrix
  var bindPose = [];      // the bind matrix
  for (var i = 0; i < 4; ++i) {
    boneUniforms.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
    bindPose.push(m4.identity());  // just allocate storage
    bones.push(m4.identity());     // just allocate storage
  }

   // rotate each bone by a and simulate a hierarchy
   function computeBoneMatrices(bones, a) {
    var m = m4.identity();
    m4.zRotate(m, a, bones[0]);
    m4.translate(bones[0], 4, 0, 0, m);
    m4.zRotate(m, a, bones[1]);
    m4.translate(bones[1], 4, 0, 0, m);
    m4.zRotate(m, a, bones[2]);
    // bones[3] is not used
  }

  // compute the initial positions of each matrix
  computeBoneMatrices(bindPose, 0);

  // compute their inverses
  var bindPoseInv = bindPose.map(function(m) {
    return m4.inverse(m);
  });

  function render(time) {
    webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    var t = time * 0.001;
    var a = Math.sin(t) * 0.8;
    computeBoneMatrices(bones, a);

    // multiply each by its bindPoseInverse
    bones.forEach(function(bone, ndx) {
      m4.multiply(bone, bindPoseInv[ndx], boneUniforms[ndx]);
    });

    gl.useProgram(skinningProgramInfo.program);
    gl.bindVertexArray(skinningVao);
    webglUtils.setUniforms(skinningProgramInfo, uniforms);
    webglUtils.drawBufferInfo(gl, skinningBufferInfo, gl.LINES);

    drawAxis(uniforms.projection, uniforms.view, bones);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);


  // --- ignore below this line - it's not relevant to the answer and it's a bad example ---

  var axisProgramInfo;
  var axisBufferInfo;
  function drawAxis(projection, view, bones) {
    if (!axisProgramInfo) {
      axisProgramInfo = webglUtils.createProgramInfo(gl, [simpleVertexShaderSource, fragmentShaderSource]);
      axisBufferInfo  = webglUtils.createBufferInfoFromArrays(gl, {
        position: {
          numComponents: 2,
          data: [
            0, 0,
            1, 0,
          ],
        },
      });
      // Create a vertex array object (attribute state)
      var axisVao = gl.createVertexArray();
      // and make it the one we're currently working with
      gl.bindVertexArray(axisVao);
      // set all the attributes
      webglUtils.setBuffersAndAttributes(gl, axisProgramInfo, axisBufferInfo);
    }

    var uniforms = {
      projection: projection,
      view: view,
    };

    gl.useProgram(axisProgramInfo.program);
    gl.bindVertexArray(axisVao);

    for (var i = 0; i < 3; ++i) {
      drawLine(bones[i], 0, [0, 1, 0, 1]);
      drawLine(bones[i], Math.PI * 0.5, [0, 0, 1, 1]);
    }

    function drawLine(mat, angle, color) {
      uniforms.model = m4.zRotate(mat, angle);
      uniforms.color = color;
      webglUtils.setUniforms(axisProgramInfo, uniforms);
      webglUtils.drawBufferInfo(gl, axisBufferInfo, gl.LINES);
    }
  }
}

main();
</script>
</html>



